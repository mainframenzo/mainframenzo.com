// This file is responsible for handling (blog) posts build logic.
import * as log from 'ts-app-logger';

import * as fs from 'node:fs';
import * as path from 'node:path';
import showdown from 'showdown';

import * as constants from './constants';
import * as iface from './iface';
import * as boms from './boms';
import * as buildSlideshows from './build-slideshows';
import * as threedSlideshows from './3d-slideshows';

// This showdown markdown extension:
// * Changes (text) to <parenthentical>(text)</parenthetical> for styling purposes
// * Force all links declared in markdown to open in new tab
// * Add ondblclick='this.requestFullscreen()' to all images declared in markdown
// Notes:
// lang: language extension to add new Markdown syntax to Showdown
// output: output extension (or modifier) to alter the HTML output generated by Showdown
// If a filter functon is present, both regex and replace properties will be ignored.
const parentheticalFormatter = {
  type: 'output',
  filter: (text: string) => {
    log.debug('showdown meblog-markdown-formatter: format parenthetical', text);

    // FIXME Two parentheticals in one paragraph formats the text in between incorrectly.
    text = text.replace(/\((.*)\)/gi, (match, text, rest) => {
      log.debug('parenthetical match', match, 'text', text, 'rest', rest);

      // This is bound to break: ondblclick='this.requestFullscreen()' gets matched,
      //  and I'm certain there will be other edge cases to account for.
      if (match === '()') { return match; }

      return `<parenthetical>(${text})</parenthetical>`;
    });

    return text;
  }
};

const linkFormatter = {
  type: 'output',
  filter: (text: string) => {
    log.debug('showdown meblog-markdown-formatter: format link', text);

    text = text.replace(/<a\s+(?:[^>]*?\s+)?href=["']([^"']*)["']([^>]*)>/gi, (match, text, rest) => {
      log.debug('match', match, 'text', text, 'rest', rest);
      
      if (match.includes('target="_blank"') || match.includes("target='_blank'") || text.startsWith('#')) {
        return match;
      }

      return `<a href='${text}' target='_blank'${rest}>`;
    });

    return text;
  }
};

const imageFormatter = {
  type: 'output',
  filter: (text: string) => {
    log.debug('showdown meblog-markdown-formatter: format image', text);

    text = text.replace(/<image[^>]+>/gi, (match, text, rest) => {
      log.debug('match', match, 'text', text, 'rest', rest);

      if (match.includes('ondblclick=')) { return match; }
      
      return match.replace(/>$/, " ondblclick='this.requestFullscreen()'>");
    });

    // You mostly use <image> tags but hell who knows what I'm smoking some days.
    text = text.replace(/<img[^>]+>/gi, (match, text, rest) => {
      log.debug('match', match, 'text', text, 'rest', rest);

      if (match.includes('ondblclick=')) { return match; }
      
      return match.replace(/>$/, " ondblclick='this.requestFullscreen()'>");
    });

    return text;
  }
};

const markdownConverter = new showdown.Converter({
  headerLevelStart: 5,
  extensions: [parentheticalFormatter, linkFormatter, imageFormatter]
});

export const getAll = async (weWant: iface.TPostFilter, postType: iface.TPostType) => {
  log.trace('getAll (posts)', postType, weWant);

  const posts: Array<iface.IPost> = [];

  await findPosts(constants.postsDir, posts, postType, weWant);

  return posts;
};

const findPosts = async (dir: string, posts: Array<iface.IPost>, postType: iface.TPostType, weWant: iface.TPostFilter) => {
  log.trace('findPosts', dir, postType);

  const entries = fs.readdirSync(dir, { withFileTypes: true });

  for (const entry of entries) {
    const childPath = path.join(dir, entry.name);

    if (entry.isDirectory()) {
      await findPosts(childPath, posts, postType, weWant);
    }

    if (!entry.isDirectory() && path.extname(childPath) === constants.postExtension) {
      const template = fs.readFileSync(childPath).toString();
      const [rawPostInfo, postInfo] = getPostInfo(template);

      // We do a bunch of filtering here. 
      // For the dev publish stage, we want to show all posts, including drafts.
      // For the prod publish stage, we only want to show published posts (and their corresponding info).
      if (postInfo.type !== postType) { 
        log.warn('ignoring post, postInfo.type !== postType', postInfo.type, postType);

        continue; 
      }

      if (weWant === 'published' && postInfo.draft) { 
        log.warn('ignoring post, weWant published but got draft');

        continue; 
      }

      if (weWant === 'draft' && !postInfo.draft) { 
        log.warn('ignoring post, weWant draft but got published');

        continue; 
      }

      if (!postInfo.title) { postInfo.title = entry.name.replace(constants.postExtension, ''); } // Derive title from file name.
      log.debug('postInfo', childPath, postInfo);

      let html = markdownConverter.makeHtml(template);

      // We could make these Markdown extensions but that seems like overkill. 
      // Instead just replace the post's HTML in a more ad-hoc manner.
      //
      // Generates boms and build slideshow HTML/JavaScript, 
      //  then insert boms and build slideshow into each post's HTML.
      html = html.replace(rawPostInfo, ''); // Remove this because otherwise when we try to substitute boms and build slideshows it will interfere.

      const bomReferences: iface.IBOMMarkdownReference[] = [];
      const buildSlideshowReferences: iface.ISlideshowMarkdownReference[] = [];
      const threedSlideshowReferences: iface.ISlideshowMarkdownReference[] = [];

      let totalCostUSDAllBoms = 0;
      if (postInfo.boms) {
        log.debug('found boms', postInfo.boms);
        
        for (const bom of postInfo.boms) {
          // Ignore boms you're using as a notepad.
          const wipBomFile = path.join(process.cwd(), `src/frontend/boms/posts/${bom.name}.wip`);
          log.debug('wipBomFile', wipBomFile);

          if (fs.existsSync(wipBomFile)) {
            log.warn('skipping bom, wip', bom.name);
        
            continue;
          }

          const [bomHtml, totalCostUSD] = await boms.generateHTML(postInfo, bom);
          totalCostUSDAllBoms = totalCostUSDAllBoms + totalCostUSD;

          log.debug('bom html', bomHtml);

          log.debug(`replacing bom.templateKey ${bom.templateKey} in post html`, html.includes(bom.templateKey));
          html = html.replace(`<p>${bom.templateKey}</p>`, bomHtml); // Wrap in <p> because we converted from Markdown without using a Showdown extension.

          bomReferences.push({ ...bom, html: bomHtml });
        }
      }

      if (postInfo.buildSlideshows) {
        log.debug('found build slideshows', postInfo.buildSlideshows);

        for (const buildSlideshow of postInfo.buildSlideshows) {
          const buildSlideshowHtml = await buildSlideshows.generateHTML(postInfo, buildSlideshow);
          log.debug('build slideshow html', buildSlideshowHtml);

          log.debug(`replacing buildSlideshow.templateKey ${buildSlideshow.templateKey} in post html`, html.includes(buildSlideshow.templateKey));
          html = html.replace(`<p>${buildSlideshow.templateKey}</p>`, buildSlideshowHtml); // Wrap in <p> because we converted from Markdown without using a Showdown extension.
 
          buildSlideshowReferences.push({ ...buildSlideshow, html: buildSlideshowHtml });
        }
      }

      if (postInfo.threedSlideshows) {
        log.debug('found 3d slideshows', postInfo.threedSlideshows);

        for (const threedSlideshow of postInfo.threedSlideshows) {
          const threedSlideshowHtml = await threedSlideshows.generateHTML(postInfo, threedSlideshow);
          log.debug('3d slideshow html', threedSlideshowHtml);

          log.debug(`replacing threedSlideshow.templateKey ${threedSlideshow.templateKey} in post html`, html.includes(threedSlideshow.templateKey));
          html = html.replace(`<p>${threedSlideshow.templateKey}</p>`, threedSlideshowHtml); // Wrap in <p> because we converted from Markdown without using a Showdown extension.
 
          threedSlideshowReferences.push({ ...threedSlideshow, html: threedSlideshowHtml });
        }
      }

      posts.push({ postInfo, html, boms: bomReferences, buildSlideshows: buildSlideshowReferences, threedSlideshows: threedSlideshowReferences, totalCostUSDAllBoms });
    }
  }
};

const getPostInfo = (template: string): [string, iface.IPostInfo] => {
  const postInfo = template.match(/<!--[\s\S]*?-->/g);

  log.trace('getPostInfo', template, postInfo || 'n/a');

  if (postInfo && postInfo[0]) {
    let postInfoString = postInfo[0];

    postInfoString = postInfoString.replace('<!--', '');
    postInfoString = postInfoString.replace('-->', '');
    postInfoString = postInfoString.replace('\n', '');

    log.debug('postInfoString', postInfoString);

    return [postInfo[0], JSON.parse(postInfoString) as iface.IPostInfo];
  }

  throw new Error('Post info not parseable');
}

export const getAllDrafts = async (postType: iface.TPostType) => {
  log.trace('getAllDrafts (posts)', postType);

  const posts: Array<iface.IPost> = [];

  await findPosts(constants.postsDir, posts, postType, 'draft');

  return posts;
};